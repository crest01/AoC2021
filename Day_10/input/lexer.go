// Code generated by re2c 2.2 on Fri Dec 10 20:56:47 2021, DO NOT EDIT.
//go:generate re2go $GOFILE.re -o $GOFILE --no-debug-info -W
package input

func lex(str *[]byte) ([][]byte, []byte, []int, [][]byte) { // Go code
	var YYMAXFILL int = 1

	str = pad(str, YYMAXFILL)
	limit := len(*str)
	var cursor int
	stack := make([]byte, 0)
	line := make([]byte, 0)
	lines := make([][]byte, 0)
	corrupt := false
	corrupt_chars := make([]byte, 0)
	corrupt_lines := make([]int, 0)
	stacks := make([][]byte, 0)

	line_idx := 0

loop:

	{
		var yych byte
		if limit-cursor < 1 {
			panic("yfill")
		}
		yych = (*str)[cursor]
		switch yych {
		case 0x00:
			goto yy2
		case '\n':
			goto yy6
		case '(':
			fallthrough
		case '<':
			fallthrough
		case '[':
			fallthrough
		case '{':
			goto yy8
		case ')':
			fallthrough
		case '>':
			fallthrough
		case ']':
			fallthrough
		case '}':
			goto yy10
		default:
			goto yy4
		}
	yy2:
		cursor += 1
		{
			if limit-cursor == YYMAXFILL-1 {
				return lines, corrupt_chars, corrupt_lines, stacks
			} else {
				panic("parse error!")
			}
		}
	yy4:
		cursor += 1
		{
			printError(str, cursor-1, cursor)
		}
	yy6:
		cursor += 1
		{
			lines = append(lines, line)
			stacks = append(stacks, stack)
			stack = make([]byte, 0)
			line = make([]byte, 0)
			line_idx++
			corrupt = false
			goto loop
		}
	yy8:
		cursor += 1
		{
			stack = append(stack, yych)
			line = append(line, yych)
			goto loop
		}
	yy10:
		cursor += 1
		{
			top_of_stack := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			closing := GetClosingBracket(top_of_stack)
			line = append(line, yych)

			if !corrupt && yych != closing {
				corrupt_chars = append(corrupt_chars, yych)
				corrupt_lines = append(corrupt_lines, line_idx)
				corrupt = true
			}
			goto loop
		}
	}

	return lines, corrupt_chars, corrupt_lines, stacks
}
